## 基础知识

### 分类

从通讯回音产生的原因看，可以分为**声学回音**（Acoustic Echo）和**线路回音**（Line Echo），相应的回声消除技术就叫声学回声消除（Acoustic Echo Cancellation，AEC）和线路回声消除（Line Echo Cancellation, LEC）。

声学回音是由于在免提或者会议应用中，扬声器的声音多次反馈到麦克风引起的（比较好理解）；线路回音是由于物理电子线路的二四线匹配耦合引起的（比较难理解）。

### 表象

影响通话质量和用户体验，更严重的还会形成震荡，产生啸叫。



### 原理

回声消除的基本原理是使用一个自适应滤波器对未知的回声信道:ω 进行参数辨识，根据扬声器信号与产生的多路回声的相关性为基础，建立远端信号模型，模拟回声路径，通过自适应算法调整，使其冲击响应和真实回声路径相逼近。然后将麦克风接收到的信号减去估计值，即可实现回声消除功能。

echo = F (fe)，函数F 被称之为回音路径。在声学回声消除里面，函数F表示声音在墙壁，天花板等表面多次反射的物理过程；在线路回声消除里面，函数F表示电子线路的二四线匹配耦合过程。求解的回音路径函数F就是一个自适应滤波器**W**(*n*)收敛的过程。

![](.\png\回声消除.png)

```
echo = x * w
d = s +echo
y' = x * w'
e = d - y'
```

式中 ω 是回声通道的时域冲击响应函数，x是远端语音；echo是所得回声；s是近端说话人语音，d为麦克风采集到的信号，yˆ是对回声信号的估计值，e为误差。

### 回音消除处理方法

#### 电路回音消除

传统的回声消除都是采用硬件方式，在硬件电路上集成DSP处理芯片，如我们常用的固定电话、手机等都有专门的回音消除处理电路。

#### 声学回音消除

1. 房间A的音频会议系统接收到房间B中的声音
2. 声音被采样，这一采样被称为回声消除参考
3. 随后声音被送到房间A的音箱和声学回声消除器中
4. 房间B的声音和房间A的声音一起被房间A的话筒拾取
5. 声音被送到声学回声消除器中，与原始的采样进行比较，移除房间B的声音

### 自适应滤波器

自适应滤波器是以输入和输出信号的统计特性的估计为依据，采取特定算法自动地调整滤波器系数，使其达到最佳滤波特性的一种算法或装置。自适应滤波器可以是连续域的或是离散域的。离散域自适应滤波器由一组抽头延迟线、可变加权系数和自动调整系数的机构组成。

自适应滤波器对输入信号序列*x*(*n*)的每一个样值，按特定的算法，更新、调整加权系数，使输出信号序列*y*(*n*)与期望输出信号序列*d*(*n*)相比较的均方误差为最小，即输出信号序列*y*(*n*)逼近期望信号序列*d*(*n*)。

以最小均方误差为准则设计的自适应滤波器的系数可以由维纳-霍甫夫方程解得。



B.维德罗提出的一种方法，能实时求解自适应滤波器系数，其结果接近维纳－霍甫夫方程近似解。这种算法称为最小均方算法或简称 LMS法。这一算法利用最陡下降法，由均方误差的梯度估计从现时刻滤波器系数向量迭代计算下一个时刻的系数向量。



自适应滤波器应用于通信领域的自动均衡、回声消除、天线阵波束形成，以及其他有关领域信号处理的参数识别、噪声消除、谱估计等方面。对于不同的应用，只是所加输入信号和期望信号不同，基本原理则是相同的。



上面这段话表明，需要求解的回音路径函数F就是一个自适应滤波器**W**(*n*)收敛的过程。所加输入信号*x*(*n*)是fe，期望信号是echo，自适应滤波器收敛后的**W**(*n*)就是回音路径函数F。 收敛之后，当实际回音发生，我们把fe通过函数**W**(*n*)，就可以得到一个很准确的echo，把混合信号直接减去echo，得到实际需要发送的语音speech，完成回声消除任务。

#### 值得注意两点

1. 自适应滤波器收敛阶段，期望信号是完全的echo，不能混杂有speech。因为speech和fe是没有关系的，会扰乱**W**(*n*)的收敛过程。也就是说要求回声消除算法开始运转后收敛要非常快，最好对方还来不及说话，你一说就收敛好了；收敛好之后，如果对方开始说话，也就是有speech混合过来，这个**W**(*n*)系数就不要变化了，需要稳定下来。
2. 回音路径可能是变化的，一旦出现变化，回声消除算法要能判断出来，因为自适应滤波器学习要重新开始，也就是**W**(*n*)需要一个新的收敛过程，以逼近新的回音路径函数F。

基本上来说，上面这两点是两难的，**一个需要自适应滤波器收敛后保持系数稳定，以保证不受speech说话干扰，另一个需要自适应滤波器随时保持更新状态，以保证能够追踪变化的回音路径。**这样一来，仅从数学算法层面，回声消除已经是难上加难！简单地说，回声消除自适应滤波器的设计具有两个互相矛盾的特性，也就是快速收敛和高度的稳定性，如何同时实现这两项特性，正是设计上的主要挑战。

## 常见情形

针对不同的情形要采取不同的回声消除策略。

### 静音

在语音段才需要做回声消除，在非语音段不会有回声，不需要做回声消除，甚至不需要发送语音信息，从而可以降低码率，节约带宽成本。

因此，准确探测语音活动十分重要。语音的探测算法叫 VAD(Voice Activity Detection）。

### 单讲

即只有远端说话的情形。

由于只有远端说话，从麦克风采集进来的语音信号只包含远端的回声，而不包含近端的语音。单讲情形下的回声消除相对比较容易处理，可以采取比较激进的处理策略。

如果确定单讲是高概率事件的情况下，可以直接地把所有语音信号都干掉，然后适当地填充舒适噪音。一般来说，在单讲情形下，用线性自适应滤波器跟踪回声馈路，可以很好地消除回声，大概能够抑制掉 18dB 的回声。

### 双讲

双讲情形下的回声消除就十分困难：一方面要保护近端的语音信号不被损伤，另外一方面还要尽量地把回声消除干净。

一般来说，在远端回声比近端语音要高大概 **6dB~8dB** 的情况下，如果要把远端回声消除干净，那么肯定会或多或少地损伤到近端语音。

另外，如果远端回声比近端语音要高出 **18dB** 以上，比如说扬声器离麦克风太近，远端回声把近端语音完全掩盖掉了，那么回声消除的效果肯定是不好的。这种情形下，可以采取比较激进的策略，把远端回声和近端语音一起干掉，然后适当地填充舒适噪音。

## AEC实现

回声消除主要包含两个步骤：线性自适应滤波和非线性处理。

线性自适应滤波就是对 fe=f(fs) 求解，建立远端回声的语音模型，进行第一轮回声消除。

非线性处理又分为两个步骤：残留回声处理和非线性剪切处理。残留回声处理进行第二轮回声消除，处理残留回声；非线性剪切处理就是对衰减量达到阈值的语音信号进行比较激进的剪切处理。

线性自适应滤波和非线性剪切处理在学术论文和开源项目中能找到东西学习。残留回声处理就很难，一般都是要靠团队自行摸索、积累和创新。

![](.\png\AEC实现.png)

### 线性自适应滤波

以远端声音信号和远端回声的相关性为基础，建立远端回声的语音模型，利用它对远端回声进行估计，目的是获得对远端回声尽量逼近的估计。我们可以把回声馈路 LRM 看作一个“环境滤波器”。

经过它的处理，远端声音信号被变成远端回声。回声消除就是要构建一个“算法滤波器”，基于对远端回声的语音模型，不断地调整该滤波器的系数，使得估计值更加逼近真实的回声。估计值越逼近真实回声，回声消除效果就越好。

自适应滤波器收敛后得到的就是需要求解的回声馈路函数 fe=f(fs)。当滤波器收敛稳定之后，输入远端声音信号 fs，就可以输出相对准确的对远端回声信号的估计值 fe。把采集到的信号减去远端回声信号的估计值 fe，就得到实际要发送的语音信号。

#### 难点

1. 快速收敛

   在收敛阶段，采集到声音信号要求只有远端的回声信号，不能混有近端的语音信号。近端的语音信号和远端的参考语音信号没有相关性，会对自适应滤波器的收敛过程造成扰乱。

   因此，我们的策略是让自适应滤波器收敛的时间尽量地短，短到收敛过程的时间段里采集进来的信号只有远端的回声信号，这样自适应滤波器收敛的效果就会很好。在收敛好之后，滤波器就稳定下来了，就可以用来过滤远端的回声信号了。

2. 动态自适应

   在收敛好稳定下来以后，自适应滤波器还要随时自动适应回声馈路的变化。自适应滤波器要能够判断回声馈路是否发生变化，并且能够重新学习和对其进行建模，不断地调整该滤波器的系数，进入一个新的收敛过程，最后快速地逼近新的回声馈路。

这两个难点是一对矛盾的特征，要求自适应滤波器一方面要能够快速收敛后保持系数高度稳定，另外一方面要能够随时保持更新状态跟踪回声馈路的变化。

#### 结构

自适应滤波器的结构采用FIR或IIR均可，由于IIR存在稳定性问题，因此一般采用FIR。

下图是自适应滤波器的一般结构：

![](.\png\自适应滤波器结构FIR.png)

上图中，x(k)为输入信号，y(k)为输出信号，d(k)为期望信号，e(k)是d(k)和y(k)的误差信号。自适应滤波器的滤波器系数受误差信号e(k)控制，根据e(k)的值和自适应算法自动调整。

### 非线性处理

#### 残留回声处理

通过自适应滤波器来消除回声，并不能百分之一百把回声消除干净，还需要进一步消除残留的回声。

一般来说，残留回声消除的策略是利用自适应滤波器处理后的残留回声与远端参考语音信号的相关性，进一步消除残留回声。相关性越大，说明残留回声越多，需要对残留回声进一步消除的程度越大；反之，相关性越小，说明残留回声较少，需要对残留回声进一步消除的程度越小。

因此，首先要通过计算残留回声与参考信号的相关矩阵，得到一个反映消除程度的衰减因子；然后将残留回声乘以**衰减因子**，从而进一步消除残留回声。

在线性自适应滤波做完了以后，可以利用残留回声和麦克风采集到的远端回声信号的相关性来检测是处于单讲还是双讲状态。根据**单讲还是双讲状态**，可以进一步调整衰减因子。

如果处于远端单讲状态，因为近端没有声音信号（没人说话），可以尽量多地抑制回声，让衰减因子尽量地小；如果处于双讲状态，因为线性自适应滤波器是在尽量不损伤近端语音音质的前提下消除回声，回声抑制量不会太大，所以衰减因子相对较大。

消除残留回声的算法难度甚高。在论文或者开源项目中甚少有可参考的东西，各家厂商都是通过私有的算法来实现的，甚至很多厂商都选择不实现。

#### 非线性剪切处理

在完成了上述处理以后，其实剩下的回声一般都比较小了，但不排除仍有一些残留的可以感知的小回声。为了进一步消除这些小回声，要根据前面处理得到的衰减量来做进一步的抑制处理。

在这里要为衰减量设定一个阈值。一般来说，这个衰减量阈值要设定得比较保守（比较高）。

如果衰减量达到或者超过设定的阈值，就表明回声消除量比较大，采集进来的语音信号很可能全部都是回声信号，那么就直接将语音信号全部消除掉，并填充舒适噪声，防止声音听感起伏。能达到那么大的衰减量，一般是处于远端单讲状态，或者远端回声信号要远远大于近端语音信号的双讲状态。

正常的双讲状态下，为了保护近端语音的音质，自适应滤波器是不会做大幅的回声消除的。因此，只要衰减量达到或者超过设定阈值，把采集到的语音信号全部消除掉是不会影响正常听音效果的。

如果衰减量没有超过设定的阈值，那么就不要进一步做回声消除了。这种情形可能是双讲状态，要保护本地语音的音质，避免本地语音被当成回声误杀。

业界一般有两种做法：一种是允许对近端声音有些许损伤也要把远端回声消除干净，另外一种是允许保留些许远端回声也不要对近端声音造成损伤。如果过分消除回声，就会造成断续的听音感觉。回声消除就是要在这两种做法之间找平衡点。

## 常见算法

LMS,NLMS,RLS,APA



### speex



### webrtc





## 调试

1. 学习回声消除的基本原理，涉及信号处理知识（从固定系数滤波器到系数自适应滤波器）和高等数学知识（梯度）等。因为不是做算法，掌握基本的就可以了。如果基础扎实，当然搞得越明白越好了。
2. 看算法代码。如果有实现的设计文档那是最好了，好多算法实现有技巧，有设计文档的话能更好的帮助理解代码。没有只能硬着头皮啃了。刚开始可能有些看不懂，多看几遍，也许每一次都会多懂一些。
3. 做个应用程序验证算法。这个应用程序输入是近端和远端的PCM文件，把EC的输出写进一个PCM文件里，看处理效果如何。这里面也可以分几小步：
   1. 设latency为零，近端和远端的PCM文件相同，理论上输出是全零数据。如果是这样，恭喜你选择的算法有一个好的base。如果不是那就需要去调算法里的一些系数了，这也许要调好多次，最终调试结果要是算法输出基本听不见回声。
   2. 设一定的latency，近端的PCM和远端的数据一样，但是近端的PCM数据相对远端的有一定的delay，这个值跟设定的latency值是一样的，这时理论上输出还是全零数据。
   3. 获取实际产品上的近端和远端PCM数据，可以近似得到近端和远端的latency。把这几个作为输入，看算法输出，也要基本听不见回声。这步调好后算法基本上就可以用了。
   4. 在具体硬件平台上去调。每个硬件平台上的latency都是不一样的。在芯片公司时有demo板，每个客户也有他们的电路板，硬件平台相对不多一个个获取近远端PCM数据调好latency就可以了。在移动互联网公司做APP时，手机类型众多，用上面方法太累，于是在UI上做了一个滑动条去配置latency，让测试人员去测试找到一个相对较好的latency，然后放在配置文件里保存下来，以后这款手机就用这个latency值了。

## 测试

[有信VoIP 语音质量评测实践](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488243&idx=1&sn=d623a1fa7327bf5da5966243d1a8c495&source=41#wechat_redirect)